import { Data, SigType } from "@ndn/packet";
import * as TestSignVerify from "@ndn/packet/test-fixture/sign-verify";
import { Decoder, fromHex } from "@ndn/tlv";

import { HmacKey, PublicKey } from "../..";

test.each(TestSignVerify.TABLE)("%p", async ({ cls }) => {
  const keyA = await HmacKey.generate("/A");
  expect(PublicKey.isExportable(keyA)).toBeFalsy();
  const keyB = await HmacKey.generate("/B");
  const record = await TestSignVerify.execute(cls, keyA, keyA, keyB, keyB);
  TestSignVerify.check(record, { deterministic: true });
  expect(record.sA0.sigInfo.type).toBe(SigType.HmacWithSha256);
  // expect(record.sA0.sigInfo.keyLocator).toBeUndefined();
});

/*
Sample packet below was generated by python-ndn version 0.2b2.post1

from ndn.encoding import make_data, MetaInfo
from ndn.security import HmacSha256Signer

key = b'\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF'
signer = HmacSha256Signer("/H/KEY/x", key)

pkt = make_data("/A", meta_info=None, signer=signer)
print(pkt.hex())
*/
test("verify", async () => {
  const wire = fromHex("063b070308014116121b01041c0d070b08014808034b4559080178172097ab86d234f84a5b3224838b9a99aa0d43fc9d6313bd772fbdc05ba79c2431cb");
  const pkt = new Decoder(wire).decode(Data);

  const key = await HmacKey.importRaw("/H/KEY/x",
    Uint8Array.of(0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF));
  await expect(key.verify(pkt)).resolves.toBeUndefined();
});
