import "@ndn/packet/test-fixture/expect";

import { Data, Name, SigType } from "@ndn/packet";
import * as TestSignVerify from "@ndn/packet/test-fixture/sign-verify";
import { Decoder, fromHex } from "@ndn/tlv";

import { generateSigningKey, HMAC, KeyChain } from "../..";

test.each(TestSignVerify.TABLE)("%p", async ({ cls }) => {
  const [pvtA, pubA] = await generateSigningKey("/A", HMAC);
  const [pvtB, pubB] = await generateSigningKey("/B", HMAC);
  const record = await TestSignVerify.execute(cls, pvtA, pubA, pvtB, pubB);
  TestSignVerify.check(record, { deterministic: true });
  expect(record.sA0.sigInfo.type).toBe(SigType.HmacWithSha256);
  expect(record.sA0.sigInfo.keyLocator?.name).toEqualName(pvtA.name);
});

test("load", async () => {
  const keyChain = KeyChain.createTemp();
  const name = new Name("/HMACKEY/KEY/x");
  await generateSigningKey(keyChain, name, HMAC);

  const keyPair = await keyChain.getKeyPair(name);
  const { signer, verifier } = keyPair;
  expect(signer.sigType).toBe(SigType.HmacWithSha256);
  expect(verifier.sigType).toBe(SigType.HmacWithSha256);
  expect(() => keyPair.publicKey).toThrow();
});

/*
Sample packet below was generated by python-ndn version 0.2b2.post1

from ndn.encoding import make_data, MetaInfo
from ndn.security import HmacSha256Signer

key = b'\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF'
signer = HmacSha256Signer("/H/KEY/x", key)

pkt = make_data("/A", meta_info=None, signer=signer)
print(pkt.hex())
*/
test("verify", async () => {
  const wire = fromHex("063b070308014116121b01041c0d070b08014808034b4559080178172097ab86d234f84a5b3224838b9a99aa0d43fc9d6313bd772fbdc05ba79c2431cb");
  const pkt = new Decoder(wire).decode(Data);

  const [, key] = await generateSigningKey("/H/KEY/x", HMAC, {
    importRaw: fromHex("A0A1A2A3A4A5A6A7A8A9AAABACADAEAF"),
  });
  await expect(key.verify(pkt)).resolves.toBeUndefined();
});
