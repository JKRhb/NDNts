import { Data, SigType } from "@ndn/packet";
import { Decoder, fromHex } from "@ndn/tlv";

import { HmacKey, PrivateKey, PublicKey } from "../..";
import * as TestSignVerify from "../../test-fixture/sign-verify";

test("isKey", async () => {
  const key = await HmacKey.generate("/H");
  expect(PrivateKey.isPrivateKey(key)).toBeTruthy();
  expect(PublicKey.isPublicKey(key)).toBeTruthy();
  await expect(key.exportAsSpki()).rejects.toThrow(/cannot export/);
});

test.each(TestSignVerify.TABLE)("%p", async ({ cls }) => {
  const keyA = await HmacKey.generate("/A");
  const keyB = await HmacKey.generate("/B");
  const record = await TestSignVerify.execute(cls, keyA, keyA, keyB, keyB);
  TestSignVerify.check(record, { deterministic: true, alwaysMatch: true });
  expect(record.sA0.sigInfo.type).toBe(SigType.HmacWithSha256);
  expect(record.sA0.sigInfo.keyLocator).toBeUndefined();
});

/*
Sample packet below was generated by python-ndn version 0.2a2

from ndn.encoding import make_data, MetaInfo
from ndn.security import HmacSha256Signer

key = b'\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF'
signer = HmacSha256Signer("/H/KEY/x", key)

pkt = make_data("/A", meta_info=None, signer=signer)
print(pkt.hex())
*/
test("verify", async () => {
  const wire = fromHex("063b070308014116121b01031c0d070b08014808034b4559080178172014d4953dd871f928268ca385e31c28567f6c253a053185c1cf15e6ef84f56c7b");
  const pkt = new Decoder(wire).decode(Data);

  const key = await HmacKey.importRaw("/H/KEY/x",
    Uint8Array.of(0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF));
  await expect(key.verify(pkt)).resolves.toBeUndefined();
});
