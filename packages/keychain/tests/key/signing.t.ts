import "@ndn/packet/test-fixture/expect";

import { Data, Name, SigType } from "@ndn/packet";
import * as TestSignVerify from "@ndn/packet/test-fixture/sign-verify";
import { Decoder, fromHex } from "@ndn/tlv";

import { Certificate, createVerifier, EcCurve, ECDSA, generateSigningKey, HMAC, KeyChain, RSA, RsaModulusLength, SigningAlgorithmListFull } from "../..";

test.each(TestSignVerify.makeTable("curve", EcCurve.Choices))("ECDSA sign-verify %p", async ({ cls, curve }) => {
  const [pvtA, pubA] = await generateSigningKey("/A/KEY/x", ECDSA, { curve });
  const [pvtB, pubB] = await generateSigningKey("/B/KEY/x", ECDSA, { curve });

  expect(pvtA.name).toEqualName("/A/KEY/x");
  expect(pubA.name).toEqualName("/A/KEY/x");
  expect(pvtB.name).toEqualName("/B/KEY/x");
  expect(pubB.name).toEqualName("/B/KEY/x");

  const record = await TestSignVerify.execute(cls, pvtA, pubA, pvtB, pubB);
  TestSignVerify.check(record);
  expect(record.sA0.sigInfo.type).toBe(SigType.Sha256WithEcdsa);
  expect(record.sA0.sigInfo.keyLocator?.name).toEqualName(pvtA.name);
});

test.each(EcCurve.Choices)("ECDSA load %p", async (curve) => {
  const keyChain = KeyChain.createTemp();
  const name = new Name("/my/KEY/x");
  await generateSigningKey(keyChain, name, ECDSA, { curve });

  const { signer, publicKey } = await keyChain.getKeyPair(name);
  expect(signer.sigType).toBe(SigType.Sha256WithEcdsa);

  const cert = await Certificate.selfSign({ privateKey: signer, publicKey });
  const verifier = await createVerifier(cert);
  expect(verifier.name).toEqualName(signer.name);
  expect(verifier.sigType).toBe(SigType.Sha256WithEcdsa);
  await verifier.verify(cert.data);
});

test.each(TestSignVerify.makeTable("modulusLength", RsaModulusLength.Choices))("RSA sign-verify %p", async ({ cls, modulusLength }) => {
  const [pvtA, pubA] = await generateSigningKey("/A/KEY/x", RSA, { modulusLength });
  const [pvtB, pubB] = await generateSigningKey("/B/KEY/x", RSA, { modulusLength });

  const record = await TestSignVerify.execute(cls, pvtA, pubA, pvtB, pubB);
  TestSignVerify.check(record, { deterministic: true });
  expect(record.sA0.sigInfo.type).toBe(SigType.Sha256WithRsa);
  expect(record.sA0.sigInfo.keyLocator?.name).toEqualName(pvtA.name);
}, 10000);

test.each(RsaModulusLength.Choices)("RSA load %p", async (modulusLength) => {
  const keyChain = KeyChain.createTemp(SigningAlgorithmListFull);
  const name = new Name("/my/KEY/x");
  await generateSigningKey(keyChain, name, RSA, { modulusLength });

  const { signer, publicKey } = await keyChain.getKeyPair(name);
  expect(signer.sigType).toBe(SigType.Sha256WithRsa);

  const cert = await Certificate.selfSign({ privateKey: signer, publicKey });
  const verifier = await createVerifier(cert, SigningAlgorithmListFull);
  expect(verifier.name).toEqualName(signer.name);
  expect(verifier.sigType).toBe(SigType.Sha256WithRsa);
  await verifier.verify(cert.data);
});

test.each(TestSignVerify.makeTable())("HMAC sign-verify %p", async ({ cls }) => {
  const [pvtA, pubA] = await generateSigningKey("/A/KEY/x", HMAC);
  const [pvtB, pubB] = await generateSigningKey("/B/KEY/x", HMAC);

  const record = await TestSignVerify.execute(cls, pvtA, pubA, pvtB, pubB);
  TestSignVerify.check(record, { deterministic: true });
  expect(record.sA0.sigInfo.type).toBe(SigType.HmacWithSha256);
  expect(record.sA0.sigInfo.keyLocator?.name).toEqualName(pvtA.name);
});

/*
Sample packet below was generated by python-ndn version 0.2b2.post1

from ndn.encoding import make_data, MetaInfo
from ndn.security import HmacSha256Signer

key = b'\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF'
signer = HmacSha256Signer("/H/KEY/x", key)

pkt = make_data("/A", meta_info=None, signer=signer)
print(pkt.hex())
*/
test("HMAC verify", async () => {
  const wire = fromHex("063b070308014116121b01041c0d070b08014808034b4559080178172097ab86d234f84a5b3224838b9a99aa0d43fc9d6313bd772fbdc05ba79c2431cb");
  const pkt = new Decoder(wire).decode(Data);

  const [, key] = await generateSigningKey("/H/KEY/x", HMAC, {
    importRaw: fromHex("A0A1A2A3A4A5A6A7A8A9AAABACADAEAF"),
  });
  await key.verify(pkt);
});
